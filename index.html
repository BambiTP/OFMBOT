<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TagPro Physics with Box2dWeb & PixiJS - Camera Follow</title>
  <style>
    body {
      margin: 0;
      background: #202020;
      overflow: hidden; /* Prevent scrolling */
    }
  </style>
</head>
<body>
  <!-- Load local copies from your folder -->
  <script src="pixi.min.js"></script>
  <script src="Box2d.min.js"></script>
  
  <script>
    /****************************************************
     * CONSTANTS & SETUP
     ****************************************************/
    // 1 TPU = 100 pixels.
    var PIXELS_PER_TPU = 100;
    // Base time step (60 FPS).
    var baseDT = 1 / 60;
    
    // TagPro physics parameters (in TPU units):
    // When a key is held, acceleration = 1.5 TPU/s² per axis.
    // Drag acts as a deceleration proportional to velocity: 0.5 × currentSpeed.
    // Maximum speed per axis: 2.5 TPU/s.
    var ACCELERATION = 1.5; // TPU/s²
    var MAX_SPEED = 2.5;    // TPU/s
    var DRAG = 0.5;         // per second
    
    // Ball dimensions: 38 px diameter (radius = 19 px).
    // Convert radius to TPU units.
    var ballRadiusTPU = 19 / PIXELS_PER_TPU;
    
    /****************************************************
     * BOX2D SETUP (Box2dWeb)
     ****************************************************/
    // Aliases for Box2dWeb classes.
    var b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2World = Box2D.Dynamics.b2World,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
    
    // Create a Box2D world with zero gravity (top-down view).
    var world = new b2World(new b2Vec2(0, 0), true);
    
    // Create the ball body.
    var bodyDef = new b2BodyDef();
    bodyDef.type = b2Body.b2_dynamicBody;
    // Start at the center of an 800×600 world (converted to TPU).
    bodyDef.position.Set(800/(2*PIXELS_PER_TPU), 600/(2*PIXELS_PER_TPU));
    var ballBody = world.CreateBody(bodyDef);
    
    // Define the ball fixture.
    var fixDef = new b2FixtureDef();
    fixDef.shape = new b2CircleShape(ballRadiusTPU);
    fixDef.density = 1.0;
    fixDef.friction = 0.3;
    fixDef.restitution = 0.2;
    ballBody.CreateFixture(fixDef);
    
    /****************************************************
     * PIXI SETUP (Rendering)
     ****************************************************/
    // Create a PixiJS Application with a 1280x800 canvas.
    var app = new PIXI.Application({
      width: 1280,
      height: 800,
      backgroundColor: 0x303030,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });
    document.body.appendChild(app.view);
    
    // Create a container for the world that we can move to simulate a camera.
    var worldContainer = new PIXI.Container();
    app.stage.addChild(worldContainer);
    
    // ---------------------------
    // TEXTURE SETUP
    // ---------------------------
    // Create a base texture from the tilesheet.
    var baseTexture = PIXI.BaseTexture.from("tiles.png");
    
    // Create a texture for the ball.
    // Ball: 3 to the right on the first row -> (3 * 40, 0 * 40) = (120, 0)
    var ballTexture = new PIXI.Texture(baseTexture, new PIXI.Rectangle(120, 0, 40, 40));
    
    // Create a texture for the floor tile.
    // Floor: 2 to the right on the 5th row -> (2 * 40, 4 * 40) = (80, 160)
    var floorTexture = new PIXI.Texture(baseTexture, new PIXI.Rectangle(80, 160, 40, 40));
    
    // Create a TilingSprite for the floor to cover an 800×600 area.
    var floorSprite = new PIXI.TilingSprite(floorTexture, 800, 600);
    worldContainer.addChild(floorSprite);
    
    // Create a Sprite for the ball.
    var ballSprite = new PIXI.Sprite(ballTexture);
    // Set the anchor to the center so that its position is centered.
    ballSprite.anchor.set(0.5);
    // Set its initial position.
    ballSprite.x = ballBody.GetPosition().x * PIXELS_PER_TPU;
    ballSprite.y = ballBody.GetPosition().y * PIXELS_PER_TPU;
    worldContainer.addChild(ballSprite);
    
    /****************************************************
     * INPUT HANDLING
     ****************************************************/
    // Global keys object.
    var keys = {};
    window.addEventListener("keydown", function(e) {
      // Prevent default arrow key actions.
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = true;
    });
    window.addEventListener("keyup", function(e) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = false;
    });
    
    /****************************************************
     * GAME LOOP
     ****************************************************/
    app.ticker.add(function(delta) {
      var frameTime = baseDT * delta;
      
      // Determine acceleration based on keys:
      var ax = 0, ay = 0;
      if (keys["ArrowLeft"] || keys["a"] || keys["A"]) {
        ax = -ACCELERATION;
      }
      if (keys["ArrowRight"] || keys["d"] || keys["D"]) {
        ax = ACCELERATION;
      }
      if (keys["ArrowUp"] || keys["w"] || keys["W"]) {
        ay = -ACCELERATION;
      }
      if (keys["ArrowDown"] || keys["s"] || keys["S"]) {
        ay = ACCELERATION;
      }
      
      // Get current velocity.
      var velocity = ballBody.GetLinearVelocity();
      var vx = velocity.x;
      var vy = velocity.y;
      
      // Compute net force: F = mass * (acceleration - DRAG * velocity)
      var mass = ballBody.GetMass();
      var forceX = mass * (ax - DRAG * vx);
      var forceY = mass * (ay - DRAG * vy);
      
      ballBody.ApplyForce(new b2Vec2(forceX, forceY), ballBody.GetWorldCenter());
      
      // Step the simulation.
      world.Step(frameTime, 8, 3);
      world.ClearForces();
      
      // Clamp velocity.
      velocity = ballBody.GetLinearVelocity();
      vx = velocity.x;
      vy = velocity.y;
      if (vx > MAX_SPEED) vx = MAX_SPEED;
      if (vx < -MAX_SPEED) vx = -MAX_SPEED;
      if (vy > MAX_SPEED) vy = MAX_SPEED;
      if (vy < -MAX_SPEED) vy = -MAX_SPEED;
      ballBody.SetLinearVelocity(new b2Vec2(vx, vy));
      
      // Update the ball's world position.
      var pos = ballBody.GetPosition();
      ballSprite.x = pos.x * PIXELS_PER_TPU;
      ballSprite.y = pos.y * PIXELS_PER_TPU;
      
      // --- Camera Follow ---
      // Center the world container so that the ball is in the middle of the screen.
      worldContainer.x = app.screen.width / 2 - ballSprite.x;
      worldContainer.y = app.screen.height / 2 - ballSprite.y;
    });
  </script>
</body>
</html>
