<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Centered Game View with Background</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      /* Use background.jpg for the entire page */
      background: url("background.jpg") no-repeat center center fixed;
      background-size: cover;
    }
    /* Center the canvas using Flexbox */
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>
  <!-- Load PixiJS and Box2dWeb -->
  <script src="pixi.min.js"></script>
  <script src="Box2d.min.js"></script>
  
  <script>
    /****************************************************
     * CONSTANTS & SETUP
     ****************************************************/
    // 1 TPU = 100 pixels.
    var PIXELS_PER_TPU = 100;
    var baseDT = 1 / 60;  // Base timestep (60 FPS)
    
    // Physics parameters.
    var ACCELERATION = 1.5; // TPU/s²
    var MAX_SPEED = 2.5;    // TPU/s
    var DRAG = 0.5;         // per second
    
    // Tile and Map dimensions.
    var TILE_SIZE = 40;      // each tile is 40×40 pixels
    var MAP_COLS = 50;
    var MAP_ROWS = 50;
    var MAP_WIDTH = MAP_COLS * TILE_SIZE;   // 2000 pixels
    var MAP_HEIGHT = MAP_ROWS * TILE_SIZE;    // 2000 pixels
    
    // Ball dimensions: 38px diameter (radius = 19px).
    var ballRadiusTPU = 19 / PIXELS_PER_TPU;
    
    /****************************************************
     * BOX2D SETUP (Box2dWeb)
     ****************************************************/
    var b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2World = Box2D.Dynamics.b2World,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
    
    // Create a Box2D world with no gravity.
    var world = new b2World(new b2Vec2(0, 0), true);
    
    // Create the ball body at the center of the map.
    var bodyDef = new b2BodyDef();
    bodyDef.type = b2Body.b2_dynamicBody;
    bodyDef.position.Set(MAP_WIDTH / (2 * PIXELS_PER_TPU), MAP_HEIGHT / (2 * PIXELS_PER_TPU));
    var ballBody = world.CreateBody(bodyDef);
    
    var fixDef = new b2FixtureDef();
    fixDef.shape = new b2CircleShape(ballRadiusTPU);
    fixDef.density = 1.0;
    fixDef.friction = 0.3;
    fixDef.restitution = 0.2;
    ballBody.CreateFixture(fixDef);
    
    /****************************************************
     * PIXI SETUP (Rendering)
     ****************************************************/
    // Create a PixiJS Application with a 1280×800 viewport.
    // Set transparent: true so that the CSS background shows through.
    var app = new PIXI.Application({
      width: 1280,
      height: 800,
      transparent: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });
    // Append the canvas to the body (it will be centered via CSS)
    document.body.appendChild(app.view);
    
    // Create a container for the world (map and ball) that we move to simulate the camera.
    var worldContainer = new PIXI.Container();
    app.stage.addChild(worldContainer);
    
    /****************************************************
     * CREATE THE STATIC MAP USING AN OFF‑SCREEN CANVAS
     ****************************************************/
    // Create an off‑screen canvas sized to the map.
    var mapCanvas = document.createElement('canvas');
    mapCanvas.width = MAP_WIDTH;
    mapCanvas.height = MAP_HEIGHT;
    var mapCtx = mapCanvas.getContext('2d');
    
    // Load the spritesheet image.
    var tileImage = new Image();
    tileImage.src = "https://static.koalabeast.com/textures/classic/tiles.png";
    tileImage.onload = function() {
      // Draw a 50×50 grid of floor tiles.
      for (var row = 0; row < MAP_ROWS; row++) {
        for (var col = 0; col < MAP_COLS; col++) {
          mapCtx.drawImage(
            tileImage,       // source image
            520, 160,         // source x, y (location of floor tile on spritesheet)
            TILE_SIZE, TILE_SIZE, // source width & height
            col * TILE_SIZE, // destination x
            row * TILE_SIZE, // destination y
            TILE_SIZE, TILE_SIZE  // destination width & height
          );
        }
      }
      // Create a PIXI texture from the off‑screen canvas.
      var mapTexture = PIXI.Texture.from(mapCanvas);
      var mapSprite = new PIXI.Sprite(mapTexture);
      // Place the map at (0, 0) in the worldContainer.
      worldContainer.addChildAt(mapSprite, 0); // add behind other objects
    };
    
    /****************************************************
     * SETUP THE BALL SPRITE
     ****************************************************/
    // Create the ball sprite from the spritesheet.
    // The ball is located at (120, 0) on the spritesheet (40×40 in size).
    var ballTexture = new PIXI.Texture(
      PIXI.BaseTexture.from("https://static.koalabeast.com/textures/classic/tiles.png"),
      new PIXI.Rectangle(560, 0, 40, 40)
    );
    var ballSprite = new PIXI.Sprite(ballTexture);
    ballSprite.anchor.set(0.5);
    ballSprite.x = ballBody.GetPosition().x * PIXELS_PER_TPU;
    ballSprite.y = ballBody.GetPosition().y * PIXELS_PER_TPU;
    worldContainer.addChild(ballSprite);
    
    /****************************************************
     * INPUT HANDLING
     ****************************************************/
    var keys = {};
    window.addEventListener("keydown", function(e) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = true;
    });
    window.addEventListener("keyup", function(e) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = false;
    });
    
    /****************************************************
     * GAME LOOP
     ****************************************************/
    app.ticker.add(function(delta) {
      var frameTime = baseDT * delta;
      
      // Determine acceleration based on keys.
      var ax = 0, ay = 0;
      if (keys["ArrowLeft"] || keys["a"] || keys["A"]) { ax = -ACCELERATION; }
      if (keys["ArrowRight"] || keys["d"] || keys["D"]) { ax = ACCELERATION; }
      if (keys["ArrowUp"] || keys["w"] || keys["W"]) { ay = -ACCELERATION; }
      if (keys["ArrowDown"] || keys["s"] || keys["S"]) { ay = ACCELERATION; }
      
      // Apply force to the ball body.
      var velocity = ballBody.GetLinearVelocity();
      var vx = velocity.x, vy = velocity.y;
      var mass = ballBody.GetMass();
      var forceX = mass * (ax - DRAG * vx);
      var forceY = mass * (ay - DRAG * vy);
      ballBody.ApplyForce(new b2Vec2(forceX, forceY), ballBody.GetWorldCenter());
      
      // Step the Box2D simulation.
      world.Step(frameTime, 8, 3);
      world.ClearForces();
      
      // Clamp velocity.
      velocity = ballBody.GetLinearVelocity();
      vx = velocity.x;
      vy = velocity.y;
      if (vx > MAX_SPEED) vx = MAX_SPEED;
      if (vx < -MAX_SPEED) vx = -MAX_SPEED;
      if (vy > MAX_SPEED) vy = MAX_SPEED;
      if (vy < -MAX_SPEED) vy = -MAX_SPEED;
      ballBody.SetLinearVelocity(new b2Vec2(vx, vy));
      
      // Update the ball sprite position.
      var pos = ballBody.GetPosition();
      ballSprite.x = pos.x * PIXELS_PER_TPU;
      ballSprite.y = pos.y * PIXELS_PER_TPU;
      
      // --- Camera Follow ---
      // Move the world container so the ball remains centered.
      worldContainer.x = app.screen.width / 2 - ballSprite.x;
      worldContainer.y = app.screen.height / 2 - ballSprite.y;
    });
  </script>
</body>
</html>
