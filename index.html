<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TagPro with Auto-Tiled Map, Collision-Based Spin, and Flag Tag</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: url("background.jpg") no-repeat center center fixed;
      background-size: cover;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>
  <!-- Load PixiJS and Box2dWeb -->
  <script src="pixi.min.js"></script>
  <script src="Box2d.min.js"></script>
  
  <script>
    /****************************************************
     * CONSTANTS & MAP SETUP
     ****************************************************/
    const TILE_SIZE = 40;         // Each tile is 40×40 pixels.
    const QUAD_SIZE = TILE_SIZE / 2; // Each quadrant is 20×20 pixels.

    // In our tile map:
    //   1 = wall tiles, 6 = floor tile
    var tileMap = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    
    // Mapping from tile code to wall properties.
    var wallTypes = {
      1: { wallSolids: 0xff },
      2: { wallSolids: 0xff },
      3: { wallSolids: 0xd2 },
      4: { wallSolids: 0x4b },
      5: { wallSolids: 0xb4 },
    };

    // Floor tile is stored under key 6.
    var tiles = {
      6: { sx: 520, sy: 160 }
    };

    function wallSolidsAt(col, row) {
      if(col < 0 || row < 0 || row >= tileMap.length || col >= tileMap[0].length) return 0;
      var code = tileMap[row][col];
      if(code === 6) return 0;
      var wt = wallTypes[code];
      return wt ? wt.wallSolids : 0;
    }
    
    // Predefined quadrant coordinates (DO NOT EDIT)
    var quadrantCoords = {
      "132": [10.5, 7.5],
      "232": [11, 7.5],
      "332": [11, 8],
      "032": [10.5, 8],
      "132d": [0.5, 3.5],
      "232d": [1, 3.5],
      "032d": [0.5, 4],
      "143": [4.5, 9.5],
      "243": [5, 9.5],
      "343": [5, 10],
      "043": [4.5, 10],
      "143d": [1.5, 2.5],
      "243d": [2, 2.5],
      "043d": [1.5, 3],
      "154": [6.5, 9.5],
      "254": [7, 9.5],
      "354": [7, 10],
      "054": [6.5, 10],
      "154d": [9.5, 2.5],
      "254d": [10, 2.5],
      "354d": [10, 3],
      "165": [0.5, 7.5],
      "265": [1, 7.5],
      "365": [1, 8],
      "065": [0.5, 8],
      "165d": [10.5, 3.5],
      "265d": [11, 3.5],
      "365d": [11, 4],
      "176": [1.5, 6.5],
      "276": [2, 6.5],
      "376": [2, 7],
      "076": [1.5, 7],
      "276d": [9, 1.5],
      "376d": [9, 2],
      "076d": [8.5, 2],
      "107": [6.5, 8.5],
      "207": [7, 8.5],
      "307": [7, 9],
      "007": [6.5, 9],
      "207d": [11, 1.5],
      "307d": [11, 2],
      "007d": [10.5, 2],
      "110": [4.5, 8.5],
      "210": [5, 8.5],
      "310": [5, 9],
      "010": [4.5, 9],
      "110d": [0.5, 1.5],
      "310d": [1, 2],
      "010d": [0.5, 2],
      "121": [9.5, 6.5],
      "221": [10, 6.5],
      "321": [10, 7],
      "021": [9.5, 7],
      "121d": [2.5, 1.5],
      "321d": [3, 2],
      "021d": [2.5, 2],
      "142": [1.5, 7.5],
      "242": [2, 7.5],
      "042": [1.5, 8],
      "142d": [10.5, 0.5],
      "242d": [11, 0.5],
      "042d": [10.5, 1],
      "153": [5.5, 6.5],
      "253": [6, 6.5],
      "353": [6, 7],
      "053": [5.5, 7],
      "153d": [5.5, 0.5],
      "253d": [6, 0.5],
      "164": [9.5, 7.5],
      "264": [10, 7.5],
      "364": [10, 8],
      "164d": [0.5, 0.5],
      "264d": [1, 0.5],
      "364d": [1, 1],
      "175": [4.5, 5.5],
      "275": [5, 5.5],
      "375": [5, 6],
      "075": [4.5, 6],
      "275d": [7, 1.5],
      "375d": [7, 2],
      "206": [4, 9.5],
      "306": [4, 10],
      "006": [3.5, 10],
      "206d": [2, 3.5],
      "306d": [2, 4],
      "006d": [1.5, 4],
      "117": [5.5, 2.5],
      "217": [6, 2.5],
      "317": [6, 4],
      "017": [5.5, 4],
      "317d": [6, 3],
      "017d": [5.5, 3],
      "120": [7.5, 9.5],
      "320": [8, 10],
      "020": [7.5, 10],
      "120d": [9.5, 3.5],
      "320d": [10, 4],
      "020d": [9.5, 4],
      "131": [6.5, 5.5],
      "231": [7, 5.5],
      "331": [7, 6],
      "031": [6.5, 6],
      "131d": [4.5, 1.5],
      "031d": [4.5, 2],
      "141": [7.5, 8.5],
      "241": [8, 8.5],
      "323": [4, 5],
      "041": [7.5, 9],
      "141d": [8.5, 3.5],
      "041d": [8.5, 4],
      "152": [8.5, 7.5],
      "252": [9, 7.5],
      "334": [2, 0],
      "052": [8.5, 8],
      "152d": [3.5, 0.5],
      "252d": [4, 0.5],
      "163": [2.5, 7.5],
      "263": [3, 7.5],
      "363": [3, 8],
      "045": [9.5, 0],
      "163d": [7.5, 0.5],
      "263d": [8, 0.5],
      "174": [3.5, 8.5],
      "274": [4, 8.5],
      "374": [4, 9],
      "056": [7.5, 5],
      "274d": [3, 3.5],
      "374d": [3, 4],
      "167": [7.5, 6.5],
      "205": [10, 8.5],
      "305": [10, 9],
      "005": [9.5, 9],
      "205d": [2, 0.5],
      "305d": [2, 1],
      "170": [6.5, 7.5],
      "216": [9, 9.5],
      "316": [9, 10],
      "016": [8.5, 10],
      "316d": [10, 5],
      "016d": [9.5, 5],
      "127": [2.5, 9.5],
      "201": [5, 7.5],
      "327": [3, 10],
      "027": [2.5, 10],
      "327d": [2, 5],
      "027d": [1.5, 5],
      "130": [1.5, 8.5],
      "212": [4, 6.5],
      "330": [2, 9],
      "030": [1.5, 9],
      "130d": [9.5, 0.5],
      "030d": [9.5, 1],
      "151": [10.5, 9.5],
      "251": [11, 9.5],
      "324": [0, 7],
      "051": [10.5, 10],
      "151d": [10.5, 4.5],
      "324d": [0, 0],
      "162": [8.5, 10.5],
      "262": [9, 10.5],
      "335": [6, 8],
      "035": [5.5, 8],
      "162d": [3.5, 2.5],
      "262d": [8, 2.5],
      "173": [0.5, 9.5],
      "273": [1, 9.5],
      "373": [1, 10],
      "046": [11.5, 7],
      "046d": [11.5, 0],
      "273d": [1, 4.5],
      "157": [11.5, 8.5],
      "204": [0, 5.5],
      "304": [0, 5],
      "057": [11.5, 9],
      "204d": [0, 4.5],
      "304d": [0, 6],
      "160": [11.5, 7.5],
      "215": [8, 6.5],
      "315": [8, 7],
      "015": [7.5, 7],
      "160d": [2.5, 4.5],
      "315d": [9, 3],
      "171": [5.5, 10.5],
      "271": [6, 10.5],
      "326": [6, 5],
      "026": [5.5, 5],
      "326d": [7, 5],
      "026d": [4.5, 5],
      "137": [3.5, 6.5],
      "202": [0, 7.5],
      "337": [4, 7],
      "037": [3.5, 7],
      "202d": [9, 4.5],
      "037d": [2.5, 3],
      "140": [11.5, 5.5],
      "213": [0, 8.5],
      "313": [0, 9],
      "040": [11.5, 5],
      "140d": [11.5, 4.5],
      "040d": [11.5, 6],
      "161": [9.5, 10.5],
      "261": [10, 10.5],
      "325": [9, 6],
      "025": [8.5, 6],
      "161d": [3.5, 1.5],
      "325d": [4, 1],
      "172": [1.5, 10.5],
      "272": [2, 10.5],
      "336": [3, 6],
      "036": [2.5, 6],
      "036d": [7.5, 1],
      "272d": [8, 1.5],
      "147": [4.5, 7.5],
      "203": [4, 3.5],
      "303": [4, 4],
      "047": [4.5, 8],
      "047d": [8.5, 5],
      "203d": [8, 4.5],
      "150": [7.5, 3.5],
      "214": [7, 7.5],
      "314": [7, 8],
      "050": [7.5, 4],
      "150d": [3.5, 4.5],
      "314d": [3, 5],
      "100": [5.5, 5.5],
      "200": [6, 5.5],
      "300": [6, 6],
      "000": [5.5, 6],
      "100d": [5.5, 8.5],
      "200d": [6, 8.5],
      "300d": [6, 10],
      "000d": [5.5, 10]
    };
    /****************************************************
     * AUTO-TILING: DRAW WALL TILE
     ****************************************************/
    function drawWallTile(ctx, col, row) {
      var tileCode = tileMap[row][col];
      var wt = wallTypes[tileCode];
      if (!wt) return;
      var solids = wt.wallSolids;
      
      for (var q = 0; q < 4; q++) {
        var mask = (solids >> (q << 1)) & 3;
        if (mask === 0) continue;
        
        var cornerX = col + ((q & 2) === 0 ? 1 : 0);
        var cornerY = row + ((((q + 1) & 2) === 0 ? 0 : 1));
        
        var aroundCorner =
          (wallSolidsAt(cornerX, cornerY) & 0xc0) |
          (wallSolidsAt(cornerX - 1, cornerY) & 0x03) |
          (wallSolidsAt(cornerX - 1, cornerY - 1) & 0x0c) |
          (wallSolidsAt(cornerX, cornerY - 1) & 0x30);
        aroundCorner = aroundCorner | (aroundCorner << 8);
        
        var startDirection = q * 2 + 1;
        var cwSteps = 0;
        while (cwSteps < 8 && (aroundCorner & (1 << (startDirection + cwSteps)))) {
          cwSteps++;
        }
        var ccwSteps = 0;
        while (ccwSteps < 8 && (aroundCorner & (1 << (startDirection + 7 - ccwSteps)))) {
          ccwSteps++;
        }
        var hasChip = (mask === 3 && (((solids | (solids << 8)) >> ((q + 2) << 1)) & 3) === 0);
        var solidStart, solidEnd;
        if (cwSteps === 8) {
          solidStart = solidEnd = 0;
        } else {
          solidEnd = (startDirection + cwSteps + 4) % 8;
          solidStart = (startDirection - ccwSteps + 12) % 8;
        }
        var key = "" + q + solidStart + solidEnd + (hasChip ? "d" : "");
        var coords = quadrantCoords[key];
        if (!coords) {
          coords = [5.5, 5.5];
        }
        var destX = col * TILE_SIZE;
        var destY = row * TILE_SIZE;
        if (q === 0) {
          destX += QUAD_SIZE;
        } else if (q === 1) {
          destX += QUAD_SIZE;
          destY += QUAD_SIZE;
        } else if (q === 2) {
          destY += QUAD_SIZE;
        }
        var srcX = coords[0] * 40;
        var srcY = coords[1] * 40;
        ctx.drawImage(tileImage, srcX, srcY, QUAD_SIZE, QUAD_SIZE, destX, destY, QUAD_SIZE, QUAD_SIZE);
      }
    }
    
    /****************************************************
     * DRAW THE FULL MAP ONTO AN OFF-SCREEN CANVAS
     ****************************************************/
    function drawMapOnCanvas(ctx) {
      for (var r = 0; r < tileMap.length; r++) {
        for (var c = 0; c < tileMap[r].length; c++) {
          var x = c * TILE_SIZE;
          var y = r * TILE_SIZE;
          var tileType = tileMap[r][c];

          // Draw the floor or wall first.
          if (tileType === 6) {
            var tile = tiles[6];
            ctx.drawImage(tileImage, tile.sx, tile.sy, TILE_SIZE, TILE_SIZE, x, y, TILE_SIZE, TILE_SIZE);
          } else {
            drawWallTile(ctx, c, r);
          }
          // We do not draw the flag tile here.
        }
      }
    }

    var MAP_ROWS = tileMap.length;
    var MAP_COLS = tileMap[0].length;
    var MAP_WIDTH = MAP_COLS * TILE_SIZE;
    var MAP_HEIGHT = MAP_ROWS * TILE_SIZE;
    
    /****************************************************
     * DEFINE THE FLAG OBJECT
     ****************************************************/
    // The flag is originally at tile (12,9) with center coordinates.
    var flag = {
      col: 12,
      row: 9,
      taken: false,
      x: 12 * TILE_SIZE + TILE_SIZE/2,
      y: 9 * TILE_SIZE + TILE_SIZE/2
    };
    
    /****************************************************
     * BOX2D & PIXI SETUP (Physics and Rendering)
     ****************************************************/
    var PIXELS_PER_TPU = 100;  // 1 TPU = 100 pixels.
    var baseDT = 1 / 60;       // Base timestep (60 FPS)
    
    // Define pickup radii constants.
    const FLAG_PICKUP_RADIUS = 15;  // 15px pickup zone around flag center.
    const BALL_PIXEL_RADIUS = 19;   // Ball radius in pixels.
    
    // For movement:
    var MAX_SPEED = 2.5;    // TPU/s
    var ACCELERATION = 0.025; // TPU per tick
    
    var b2Vec2 = Box2D.Common.Math.b2Vec2,
        b2BodyDef = Box2D.Dynamics.b2BodyDef,
        b2Body = Box2D.Dynamics.b2Body,
        b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
        b2World = Box2D.Dynamics.b2World,
        b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
    
    var world = new b2World(new b2Vec2(0, 0), true);
    
    // Helper functions to disable/enable collisions (set fixtures as sensors).
    function disableCollisions(body) {
      var fixture = body.GetFixtureList();
      while (fixture) {
        fixture.SetSensor(true);
        fixture = fixture.GetNext();
      }
    }
    function enableCollisions(body) {
      var fixture = body.GetFixtureList();
      while (fixture) {
        fixture.SetSensor(false);
        fixture = fixture.GetNext();
      }
    }
    
    // Create the controlled ball body.
    var bodyDef = new b2BodyDef();
    bodyDef.type = b2Body.b2_dynamicBody;
    bodyDef.bullet = true;
    // Starting position for controlled ball.
    var controlledStart = new b2Vec2((2 * 40 - 20) / PIXELS_PER_TPU, (18 * 40 + 20) / PIXELS_PER_TPU);
    bodyDef.position.Set(controlledStart.x, controlledStart.y);
    bodyDef.linearDamping = 0.5;
    bodyDef.angularDamping = 0.5;
    var controlledBall = world.CreateBody(bodyDef);
    var fixDef = new b2FixtureDef();
    fixDef.shape = new b2CircleShape(19 / PIXELS_PER_TPU);
    fixDef.density = 1;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;
    controlledBall.CreateFixture(fixDef);
    // Store starting position and flag property.
    controlledBall.SetUserData({ id: 1, controlled: true, hasFlag: false, startPos: controlledStart, canMove: true });
    
    // Create the non-controlled ball.
    var ncBodyDef = new b2BodyDef();
    ncBodyDef.type = b2Body.b2_dynamicBody;
    ncBodyDef.bullet = true;
    // Starting position for non-controlled ball.
    var nonControlledStart = new b2Vec2((23 * TILE_SIZE + 20) / PIXELS_PER_TPU, (2 * TILE_SIZE - 20) / PIXELS_PER_TPU);
    ncBodyDef.position.Set(nonControlledStart.x, nonControlledStart.y);
    var nonControlledBall = world.CreateBody(ncBodyDef);
    var ncFixDef = new b2FixtureDef();
    ncFixDef.shape = new b2CircleShape(19 / PIXELS_PER_TPU);
    ncFixDef.density = 1;
    ncFixDef.friction = 0.5;
    ncFixDef.restitution = 0.2;
    nonControlledBall.CreateFixture(ncFixDef);
    nonControlledBall.SetUserData({ id: 2, controlled: false, hasFlag: false, startPos: nonControlledStart, canMove: true });
    
    // Create static wall bodies for tile code 1.
    var b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
    for (var row = 0; row < tileMap.length; row++) {
      for (var col = 0; col < tileMap[row].length; col++) {
        if (tileMap[row][col] === 1) {
          var wallBodyDef = new b2BodyDef();
          wallBodyDef.type = b2Body.b2_staticBody;
          wallBodyDef.position.Set(
            (col * TILE_SIZE + TILE_SIZE / 2) / PIXELS_PER_TPU,
            (row * TILE_SIZE + TILE_SIZE / 2) / PIXELS_PER_TPU
          );
          var wallBody = world.CreateBody(wallBodyDef);
          var wallFixDef = new b2FixtureDef();
          wallFixDef.shape = new b2PolygonShape();
          wallFixDef.shape.SetAsBox((TILE_SIZE / 2) / PIXELS_PER_TPU, (TILE_SIZE / 2) / PIXELS_PER_TPU);
          wallBody.CreateFixture(wallFixDef);
        }
      }
    }
    
    /****************************************************
     * EXPLOSION FUNCTION
     * When a ball dies, we create an explosion at its position.
     * All other balls within blastRadius (1.6 TPU) get a speed boost:
     *   speedboost = strength * (blastRadius - distance)
     * with strength = 0.25.
     ****************************************************/
    function createExplosionAt(position, dyingBody) {
      var blastRadius = 0.4 * 4; // 1.6 TPU
      var strength = 2;
      var body = world.GetBodyList();
      while (body) {
        var data = body.GetUserData();
        // Apply explosion to bodies that have an id and are not the dying body.
        if (data && data.id && body !== dyingBody) {
          var pos = body.GetPosition();
          var dx = pos.x - position.x;
          var dy = pos.y - position.y;
          var distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < blastRadius) {
            var boostMagnitude = strength * (blastRadius - distance);
            if (distance > 0) {
              var unitX = dx / distance;
              var unitY = dy / distance;
              var currentVel = body.GetLinearVelocity();
              body.SetLinearVelocity(new b2Vec2(currentVel.x + unitX * boostMagnitude, currentVel.y + unitY * boostMagnitude));
            }
          }
        }
        body = body.GetNext();
      }
    }
    
    /****************************************************
     * BOX2D CONTACT LISTENER (Spin Adjustment, Flag Tag,
     * Sound, Explosion, and Freeze on Death)
     ****************************************************/
    var listener = new Box2D.Dynamics.b2ContactListener();
    listener.BeginContact = function(contact) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      var dataA = bodyA.GetUserData();
      var dataB = bodyB.GetUserData();
      
      // --- FLAG TAG LOGIC & DEATH EFFECTS ---
      // Only allow tagging if both balls are "alive" (i.e. can move)
      if (dataA && dataB && dataA.hasFlag !== undefined && dataB.hasFlag !== undefined) {
        // If one has the flag and the other does not, then the flag-holder "dies"
        // and its collisions are disabled (by setting its fixtures as sensors) and moved
        // to spawn. Also, play a pop sound and create an explosion.
        // But if the ball trying to tag is dead (canMove === false) then do nothing.
        if (dataA.hasFlag && !dataB.hasFlag) {
          if (!dataB.canMove) return; // If ball B is dead, don't tag.
          // Ball A (flag carrier) dies.
          dataA.canMove = false;
          var audio = new Audio("pop.mp3");
          audio.play();
          createExplosionAt(bodyA.GetPosition(), bodyA);
          
          disableCollisions(bodyA);
          if (dataA.sprite) { dataA.sprite.visible = false; }
          dataA.hasFlag = false;
          dataB.hasFlag = true;
          console.log("Ball A with flag got tagged and died. Flag transferred to Ball B.");
          if (!dataA.isRespawning) {
            dataA.isRespawning = true;
            setTimeout(function(){
              bodyA.SetPosition(dataA.startPos);
              bodyA.SetLinearVelocity(new b2Vec2(0,0));
              if (dataA.sprite) { dataA.sprite.visible = true; }
              enableCollisions(bodyA);
              dataA.isRespawning = false;
              dataA.canMove = true;
            }, 3000);
          }
        } else if (dataB.hasFlag && !dataA.hasFlag) {
          if (!dataA.canMove) return; // If ball A is dead, don't tag.
          dataB.canMove = false;
          var audio = new Audio("pop.mp3");
          audio.play();
          createExplosionAt(bodyB.GetPosition(), bodyB);
          
          disableCollisions(bodyB);
          if (dataB.sprite) { dataB.sprite.visible = false; }
          dataB.hasFlag = false;
          dataA.hasFlag = true;
          console.log("Ball B with flag got tagged and died. Flag transferred to Ball A.");
          if (!dataB.isRespawning) {
            dataB.isRespawning = true;
            setTimeout(function(){
              bodyB.SetPosition(dataB.startPos);
              bodyB.SetLinearVelocity(new b2Vec2(0,0));
              if (dataB.sprite) { dataB.sprite.visible = true; }
              enableCollisions(bodyB);
              dataB.isRespawning = false;
              dataB.canMove = true;
            }, 5000);
          }
        }
      }
      
      // --- SPIN ADJUSTMENT LOGIC ---
      if ((dataA && dataA.controlled) || (dataB && dataB.controlled)) {
        var controlledBody = dataA && dataA.controlled ? bodyA : bodyB;
        var worldManifold = new Box2D.Collision.b2WorldManifold();
        contact.GetWorldManifold(worldManifold);
        var normal = worldManifold.m_normal;
        var tangent = new b2Vec2(-normal.y, normal.x);
        var velocity = controlledBody.GetLinearVelocity();
        var dot = velocity.x * tangent.x + velocity.y * tangent.y;
        var sign = (dot >= 0) ? 1 : -1;
        var speed = velocity.Length();
        var ballRadius = 19 / PIXELS_PER_TPU;
        var expectedAngularVel = sign * (speed / ballRadius);
        var currentAngularVel = controlledBody.GetAngularVelocity();
        var adjustmentFactor = 0.11;
        var newAngularVel = currentAngularVel + adjustmentFactor * (expectedAngularVel - currentAngularVel);
        controlledBody.SetAngularVelocity(newAngularVel);
      }
    };
    world.SetContactListener(listener);
    
    // Log angular velocity for debugging.
    setInterval(function() {
      if (controlledBall) {
        console.log("Controlled Ball Angular Velocity:", controlledBall.GetAngularVelocity());
      }
    }, 1000);
    
    /****************************************************
     * PIXI SETUP & MAP / SPRITE CREATION
     ****************************************************/
    var app = new PIXI.Application({
      width: 1280,
      height: 800,
      transparent: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });
    document.body.appendChild(app.view);
    
    var worldContainer = new PIXI.Container();
    app.stage.addChild(worldContainer);
    
    // Off-screen canvas for the map.
    var mapCanvas = document.createElement('canvas');
    mapCanvas.width = MAP_WIDTH;
    mapCanvas.height = MAP_HEIGHT;
    var mapCtx = mapCanvas.getContext('2d');
    
    // Global declarations for flag sprites.
    var flagSprite;
    var miniFlagSprite; // This will be the shrunken flag following the flag holder.
    
    // Load the tilesheet image.
    var tileImage = new Image();
    tileImage.crossOrigin = "anonymous";
    tileImage.src = "https://static.koalabeast.com/textures/classic/tiles.png";
    tileImage.onload = function() {
      drawMapOnCanvas(mapCtx);
      var mapTexture = PIXI.Texture.from(mapCanvas);
      var mapSprite = new PIXI.Sprite(mapTexture);
      worldContainer.addChildAt(mapSprite, 0);
      
      // Create the flag sprite using the original flag texture.
      var baseTextureForFlag = PIXI.BaseTexture.from("https://static.koalabeast.com/textures/classic/tiles.png");
      var flagTexture = new PIXI.Texture(baseTextureForFlag, new PIXI.Rectangle(520, 40, 40, 40));
      flagSprite = new PIXI.Sprite(flagTexture);
      flagSprite.anchor.set(0.5);
      flagSprite.x = flag.x;
      flagSprite.y = flag.y;
      worldContainer.addChild(flagSprite);
      
      // Create mini flag sprite (a shrunken version) that will follow the flag holder.
      var miniFlagTexture = new PIXI.Texture(baseTextureForFlag, new PIXI.Rectangle(520, 40, 40, 40));
      miniFlagSprite = new PIXI.Sprite(miniFlagTexture);
      miniFlagSprite.anchor.set(0.5);
      miniFlagSprite.scale.set(0.5); // Adjust scale as needed.
      miniFlagSprite.visible = false;
      worldContainer.addChild(miniFlagSprite);
    };
    
    // Create ball textures.
    var baseTexture = PIXI.BaseTexture.from("https://static.koalabeast.com/textures/classic/tiles.png");
    var ballTexture = new PIXI.Texture(baseTexture, new PIXI.Rectangle(560, 0, 40, 40));
    var ballTexture2 = new PIXI.Texture(baseTexture, new PIXI.Rectangle(600, 0, 40, 40));
    
    // Create controlled ball sprite.
    var ballSprite = new PIXI.Sprite(ballTexture);
    ballSprite.anchor.set(0.5);
    ballSprite.x = controlledBall.GetPosition().x * PIXELS_PER_TPU;
    ballSprite.y = controlledBall.GetPosition().y * PIXELS_PER_TPU;
    worldContainer.addChild(ballSprite);
    
    // Create non-controlled ball sprite.
    var ncBallSprite = new PIXI.Sprite(ballTexture2);
    ncBallSprite.anchor.set(0.5);
    ncBallSprite.x = nonControlledBall.GetPosition().x * PIXELS_PER_TPU;
    ncBallSprite.y = nonControlledBall.GetPosition().y * PIXELS_PER_TPU;
    worldContainer.addChild(ncBallSprite);
    
    // Store sprite references in user data.
    controlledBall.GetUserData().sprite = ballSprite;
    nonControlledBall.GetUserData().sprite = ncBallSprite;
    
    /****************************************************
     * INPUT HANDLING
     ****************************************************/
    var keys = {};
    window.addEventListener("keydown", function(e) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = true;
    });
    window.addEventListener("keyup", function(e) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
      keys[e.key] = false;
    });
    
    /****************************************************
     * GAME LOOP: STEP PHYSICS, UPDATE SPRITES, FLAG PICKUP
     ****************************************************/
    app.ticker.add(function(delta) {
      // --- Process input for the controlled ball only if it can move ---
      var controlledData = controlledBall.GetUserData();
      if (controlledData.canMove !== false) {
        var currentVel = controlledBall.GetLinearVelocity();
        var newVel = new b2Vec2(currentVel.x, currentVel.y);
    
        if (keys["ArrowLeft"] || keys["a"] || keys["A"]) {
          if (newVel.x > -MAX_SPEED) newVel.x -= ACCELERATION;
        }
        if (keys["ArrowRight"] || keys["d"] || keys["D"]) {
          if (newVel.x < MAX_SPEED) newVel.x += ACCELERATION;
        }
        if (keys["ArrowUp"] || keys["w"] || keys["W"]) {
          if (newVel.y > -MAX_SPEED) newVel.y -= ACCELERATION;
        }
        if (keys["ArrowDown"] || keys["s"] || keys["S"]) {
          if (newVel.y < MAX_SPEED) newVel.y += ACCELERATION;
        }
        
        controlledBall.SetLinearVelocity(newVel);
        controlledBall.SetAwake(true);
      } else {
        // If the ball cannot move (e.g. after dying), ensure its velocity stays zero.
        controlledBall.SetLinearVelocity(new b2Vec2(0,0));
      }
    
      // Step physics.
      world.Step(baseDT, 8, 3);
      world.ClearForces();
    
      // Update sprites based on body positions.
      var pos = controlledBall.GetPosition();
      ballSprite.x = pos.x * PIXELS_PER_TPU;
      ballSprite.y = pos.y * PIXELS_PER_TPU;
      ballSprite.rotation = controlledBall.GetAngle();
      
      var ncPos = nonControlledBall.GetPosition();
      ncBallSprite.x = ncPos.x * PIXELS_PER_TPU;
      ncBallSprite.y = ncPos.y * PIXELS_PER_TPU;
      ncBallSprite.rotation = nonControlledBall.GetAngle();
      
      // Camera follows the controlled ball.
      worldContainer.x = app.screen.width / 2 - ballSprite.x;
      worldContainer.y = app.screen.height / 2 - ballSprite.y;
      
      /****************************************************
       * FLAG PICKUP LOGIC:
       * Check if the distance between a ball’s center and the flag’s
       * center is less than (FLAG_PICKUP_RADIUS + BALL_PIXEL_RADIUS).
       * When the flag is picked up, update the flag sprite texture.
       ****************************************************/
      if (!flag.taken && flagSprite) {
        var flagCenterX = flag.x;
        var flagCenterY = flag.y;
        var pickupDistance = FLAG_PICKUP_RADIUS + BALL_PIXEL_RADIUS; // 15 + 19 = 34px
    
        // Check controlled ball.
        var controlledPos = controlledBall.GetPosition();
        var controlledX = controlledPos.x * PIXELS_PER_TPU;
        var controlledY = controlledPos.y * PIXELS_PER_TPU;
        var dx = controlledX - flagCenterX;
        var dy = controlledY - flagCenterY;
        if (Math.sqrt(dx * dx + dy * dy) < pickupDistance) {
          flag.taken = true;
          controlledBall.GetUserData().hasFlag = true;
          // Change the flag sprite texture to the new rectangle.
          flagSprite.texture = new PIXI.Texture(
            PIXI.BaseTexture.from("https://static.koalabeast.com/textures/classic/tiles.png"),
            new PIXI.Rectangle(520, 80, 40, 40)
          );
          console.log("Controlled ball picked up the flag!");
        }
        
        // Check non-controlled ball if flag still not taken.
        if (!flag.taken) {
          var ncPos = nonControlledBall.GetPosition();
          var ncX = ncPos.x * PIXELS_PER_TPU;
          var ncY = ncPos.y * PIXELS_PER_TPU;
          dx = ncX - flagCenterX;
          dy = ncY - flagCenterY;
          if (Math.sqrt(dx * dx + dy * dy) < pickupDistance) {
            flag.taken = true;
            nonControlledBall.GetUserData().hasFlag = true;
            flagSprite.texture = new PIXI.Texture(
              PIXI.BaseTexture.from("https://static.koalabeast.com/textures/classic/tiles.png"),
              new PIXI.Rectangle(520, 80, 40, 40)
            );
            console.log("Non-controlled ball picked up the flag!");
          }
        }
      }
      
      /****************************************************
       * MINI FLAG SPRITE LOGIC:
       * If a ball holds the flag, hide the full-sized flag sprite
       * and position the shrunken mini flag above the ball.
       ****************************************************/
      if (controlledBall.GetUserData().hasFlag) {
         miniFlagSprite.visible = true;
         miniFlagSprite.x = ballSprite.x;
         miniFlagSprite.y = ballSprite.y - ballSprite.height/2 - 10;
      } else if (nonControlledBall.GetUserData().hasFlag) {
         miniFlagSprite.visible = true;
         miniFlagSprite.x = ncBallSprite.x;
         miniFlagSprite.y = ncBallSprite.y - ncBallSprite.height/2 - 10;
      } else {
         miniFlagSprite.visible = false;
      }
    });
  </script>
</body>
</html>
